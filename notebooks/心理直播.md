
# 心理直播h5项目总结
- [微信小程序直播总结](https://github.com/yjh30/miniprogram-pit)
- 前端框架：vue.js 
- 服务端脚本：nodejs 
- 运行平台：微信浏览器 

[TOC]

#### 1、用户体验（浏览器历史记录前进后退，保留路由页面滚动位置）
见：[Vue Router异步滚动](https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html#滚动行为)
该功能只是针对document.body滚动位置有效，遇到无限滚动加载的页面配合使用Vue内置组件[keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)

#### 2、确保当前路由页面离开之后不会产生任何的副作用代码
- 清除各种轮询定时器
- 移除绑定在window,document.documentElement,document.body，非dom的全局性事件监听器
- 涉及全局性的操作需要非常谨慎，异步设置全局性的操作需要判断是在当前路由页面操作。如：在获取java接口成功后动态的设置页面标题，配置微信分享
```js
// 路径为/home的页面代码，在请求非常慢未完成的情况下，路由跳转到其他页面，如果不加路由判断那么就会有问题
this.$request.get('/getdata')
  then(res => {
    if (this.$route.path === '/home') {
      // document.title ...
      // wx.config ...
    }
  })
```

#### 3、微信分享问题
##### 3.1、排查invalid signature，一般出现这个问题有两点：
  - 检查wx.config配置的appId是否一致
  - 检查请求后端签名接口的url（本人曾意外使用了两次encodeURIComponent）

##### 3.2、版本判断，引用微信jssdk1.4.0，且微信版本大于等于6.7.2，则使用最新的分享朋友，分享到朋友圈api

#### 4、jsonp请求工具函数封装总结
- 无法获取script请求的响应内容
- 如果script标签src地址响应的不是正确的函数执行代码，做超时处理

```js
import qs from 'qs';

let id = 1;

/**
 * jsonp请求
 */
export default function(url, params = {}) {
  const callbackName = `jsonp${Date.now()}${id++}`;
  const el = document.createElement('script');

  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject({
        message: '请求超时~',
        url,
      });
    }, 5000);

    window[callbackName] = res => {
      clearTimeout(timeoutId);
      resolve(res || {});
    };

    el.onerror = function() {
      clearTimeout(timeoutId);
      document.body.removeChild(el);

      reject({
        message: '当前网络不佳，请稍后再试',
        url,
      });
    };

    el.onload = function(e) {
      clearTimeout(timeoutId);
      document.body.removeChild(el);
    };

    let src = `${url.split('#')[0]}?callback=${callbackName}`;

    if (Object.keys(params || {}).length > 0) {
      src = `${src}&${qs.stringify(params)}`;
    }

    el.src = src;
    document.body.appendChild(el);
  });
}
```

#### 5、列表分页无限加载需要注意的问题
- 由于是单页应用，数据驱动，在满足请求下一页的情况下，需做一下延时阻塞处理，否则会出现在滚动满足请求条件的情况下请求多页数据

```js
  async scrollEventListener() {
    if (this.loading || (this.pageIndex !== 1 && this.pageIndex >= this.totalPages)) {
      return;
    }

    const { clientHeight, scrollHeight } = document.documentElement;
    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop || window.scrollTop;

    if (scrollTop + clientHeight >= scrollHeight) {
      this.loading = true;
      this.errorMsg = '';

      // 单页应用，数据驱动，
      await new Promise(r => {
        setTimeout(r, 500);
      });

      this.pageIndex++;
      await this.requestNextPageData();
      this.loading = false;
    }
  }
```

#### 6、理解页面路由守卫beforeRouteEnter中执行next(false)
- 首先执行next(false)不会执行路由匹配组件的生命周期函数
- 当前路由的路径是上一个路由的路径而不是当前执行next(false)所在组件的路由path

```js
// 当重定向授权成功后 按历史记录返回键返回时并不是该代码段所在组件匹配到的路由path
beforeRouteEnter(to, from, next) {
  // 客户端未授权
  if (typeof window !== 'undefined' && !window.openId) {
    // 重定向微信授权，逻辑省略...
    next(false)
    return;
  }
  next()
}

// 当重定向授权成功后 按历史记录返回键返回正常
beforeRouteEnter(to, from, next) {
  next(vm => {
    // 服务端执行 或 已授权
    if (vm.$isServer || window.openId) {
      return;
    }
    // 重定向微信授权，逻辑省略...
  });
}
```

#### 7、微信浏览器内核的一些问题
- video标签正在播放状态时，路由无法跳转，路由离开之前需暂停video播放
- 安卓微信app支持video小窗播放，需增加x5-playsinlines属性

```html
<video
  v-if="liveData.videoSrc"
  ref="video"
  class="live-player"
  :src="liveData.videoSrc"
  :poster="liveData.coverImageUrl"
  preload
  controls
  x5-playsinline
  webkit-playsinline="isiPhoneShowPlaysinline"
  playsinline="isiPhoneShowPlaysinline">
</video>
```

#### 8、使用canvas开发一个loading组件总结
- 新思路：当前的弧度由当前时间的秒跟毫秒决定

```js
export default {
  mounted() {
    this.init();
  },
  methods: {
    init() {
      const canvas = this.$refs['canvas'];
      const ctx = canvas.getContext('2d');

      let size = this.size;
      let lineWidth = this.lineWidth;

      if (navigator.userAgent.toLowerCase().match('iphone')) {
        size *= window.devicePixelRatio;
        lineWidth *= window.devicePixelRatio;
      } else {
        size *= 2;
        lineWidth *= 2;
      }

      const radius = size / 2;
      canvas.width = size;
      canvas.height = size;
      ctx.lineWidth = lineWidth;

      let reqAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;

      if (typeof reqAnimFrame === 'undefined') {
        reqAnimFrame = callback => {
          setTimeout(callback, 16);
        };
      }

      const draw = () => {
        ctx.clearRect(0, 0, size, size);
        ctx.save();
        ctx.translate(radius, radius);

        const time = new Date();
        const currentTimeRadian =
          ((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds();
        ctx.rotate(currentTimeRadian * this.speed);
        ctx.beginPath();
        ctx.arc(0, 0, radius - ctx.lineWidth, 0, Math.PI * 1.5, false);
        ctx.strokeStyle = this.strokeColor;
        ctx.stroke();

        ctx.restore();
        reqAnimFrame(draw);
      };

      reqAnimFrame(draw);
    },
  }
};
```